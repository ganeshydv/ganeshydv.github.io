# StampedLock
- `Optimistic Lock + Passimistic Lock [ReadWriteLock]`
- `Optimistic Lock: No locking` 
- `Passimistic Lock`: Locking on `Code` (Locking-code block irrespective of instance) or `Object`(Synchronized)
- In StampedLock when putting lock(), we get one stamp of `type long` which indicates current version and need to give same stamp in `unlock(stamp)`
- `lock.validate(stamp)`: for validating the state for particular block of code this is to check that is there any other thread accessed this block of code already and executed properly
## ReadLock:
### üîí What it is:
- Pessimistic read lock, blocks if a write is happening.
- Allows multiple concurrent readers.
- No writer allowed while readers hold the lock.
### üí°Real-world analogy:
- You and others are allowed to read a document as long as no one is editing it.
```java
StampedLock lock = new StampedLock();

long stamp = lock.readLock(); // blocks if write lock is held
try {
    int value = sharedData;
    // safely use value
} finally {
    lock.unlockRead(stamp);
}
```

### ‚úÖ Characteristics:
- Safe.
- Slower than optimistic, better for consistency.
- Writer waits for readers to release.


## WriteLock:
### ‚úçÔ∏è What it is:
- Exclusive lock, only one thread can write.
- Blocks readers and writers until released.
### üí° Real-world analogy:
- You are editing the document and don‚Äôt allow anyone to read or write until you‚Äôre done.


```java
StampedLock lock = new StampedLock();

long stamp = lock.writeLock(); // blocks all
try {
    sharedData = 42; // modify data
} finally {
    lock.unlockWrite(stamp);
}
```
‚úÖ Characteristics:
- Full control.
- Ensures `atomic` and exclusive modifications.
- `Can deadlock if used carelessly in large systems.`

## Optimistic Read Lock:
### ‚úÖ What it is:
   - Non-blocking, lightweight read.
   - Allows other threads to write concurrently.
   - Must validate before using data, to ensure no write happened during the read.
### üí° Real-world analogy:
You're reading a whiteboard assuming no one will update it. Before using the info, you peek again to confirm it hasn‚Äôt changed.

```java
StampedLock lock = new StampedLock();

long stamp = lock.tryOptimisticRead();
try {
    int value = sharedData; // read shared data
    if (!lock.validate(stamp)) {
        // Fallback to readLock() if data was modified
        stamp = lock.readLock();
        try {
            value = sharedData;
        } finally {
            lock.unlockRead(stamp);
        }
    }
    // use value
} finally {
    // nothing to unlock for optimistic read
}

```

## ‚úÖ In StampedLock, when does the stamp change?
### ‚úîÔ∏è Short answer:
The stamp always changes on a writeLock() or when unlockWrite() is called, and may or may not change for read locks, but optimistic read relies on that change to detect modifications.
### üîÑ What is the ‚Äústamp‚Äù?
- A long value returned by any lock method in StampedLock.
- Acts as a version or token representing the current state of the lock.
- Internally, it's incremented whenever a write lock is acquired or released.
- You use it to validate if optimistic reads are still valid using validate(stamp).

| Lock Type             | Stamp Changed? | Notes                                                                |
| --------------------- | -------------- | -------------------------------------------------------------------- |
| `writeLock()`         | ‚úÖ Yes          | Acquiring write lock increments the internal version (stamp changes) |
| `unlockWrite()`       | ‚úÖ Yes          | Releasing write lock also increments the version                     |
| `readLock()`          | ‚ùå No           | Does not affect the stamp version                                    |
| `unlockRead()`        | ‚ùå No           | Does not affect the stamp version                                    |
| `tryOptimisticRead()` | ‚ùå No           | Returns current stamp; doesn't modify it                             |
| `validate(stamp)`     | ‚ùå No           | Only checks if the stamp is still valid                              |


### ‚úÖ Characteristics:
- Fastest, but not safe alone if data might change.
- Suitable for mostly-read systems (e.g., caching).